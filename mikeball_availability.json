// scrape_mikeball.js
// Node 20+, Playwright. Scrapes departures + expanded cabin details, filters by date window.

import { chromium } from "playwright";
import fs from "fs/promises";

// ---- CONFIG ----
const URL = "https://www.mikeball.com/availability-mike-ball-dive-expeditions/";
// Inclusive date window (adjust as needed)
const FROM = new Date("2025-10-01");
const TO   = new Date("2026-10-30");

function parseAusMoney(s) {
  if (!s) return null;
  const n = String(s).replace(/[^\d.]/g, "");
  return n ? Math.round(parseFloat(n)) : null;
}
function normStatus(s) {
  const t = (s||"").toLowerCase();
  if (t.includes("sold")) return "Sold Out";
  if (t.includes("hurry") || t.includes("few")) return "Few left";
  if (t.includes("avail") || t.includes("10+")) return "Available";
  return s || "—";
}
function dmyToISO(dep, ret) {
  // Accepts things like "Thu 11 Sep 2025" -> Date
  const toDate = (txt) => {
    if (!txt) return null;
    // Remove weekday if present
    const clean = txt.replace(/^[A-Za-z]{3,}\s+/,'');
    return new Date(clean);
  };
  return { depart: toDate(dep), ret: toDate(ret) };
}
function inWindow(d) { return d && d >= FROM && d <= TO; }

(async () => {
  const browser = await chromium.launch({ headless: true });
  const page = await browser.newPage({ viewport: { width: 1280, height: 2000 } });
  await page.goto(URL, { waitUntil: "domcontentloaded" });

  // Let the page load dynamic content
  await page.waitForTimeout(2000);

  // Click all "See more" toggles so cabin tables are present in the DOM.
  // Selector may vary; adjust if site changes:
  // Try common patterns: button text contains "See more"
  const moreButtons = await page.locator('text=/^\\s*See more\\s*$/i').all();
  for (const btn of moreButtons) {
    try { await btn.click({ timeout: 1000 }); } catch {}
  }

  // Wait a bit for expanded rows to render
  await page.waitForTimeout(1500);

  // Grab all top-level rows. We select rows by looking for the columns: title + dates + price + availability.
  // We'll be generous with selectors; tune if needed:
  const rows = await page.locator("table,div")
    .filter({ hasText: "Expeditions" }) // try to scope near that table; if this doesn't work, just query all rows below the header
    .all();

  // If the above scoping is brittle, fallback: query all visible rows by common patterns:
  const items = await page.locator("tr,div.availability-row").all();

  const trips = [];
  // We'll walk through all potential row containers and try to read fields by regex + nearby labels.
  // A robust approach: find all blocks that look like a departure line (must have Depart/Return/Price/Availability).
  const textAll = await page.content();

  // A simpler approach: query each visible "departure card/row" by CSS classes Mike Ball uses.
  // If classes differ, use text-based extraction:
  const cards = await page.locator("tbody tr:has-text('Night'), tbody tr:has-text('Fly Dive'), tbody tr:has-text('Exploratory'), tbody tr:has-text('Minke'), tbody tr:has-text('Ribbon')").all();

  // Helper to extract cabin rows under an expanded area near this row index
  async function extractCabinsNear(idx) {
    // Look for a following row with cabin table
    const cabinRows = await page.locator(`#cabins-${idx}, tr:has-text('Cabin Type') + tr, tr:has-text('Cabin Type')`).all();
    // Fallback: search within the next sibling block
    const cabins = [];
    // As a generic approach, scan for any subtable with headers "Cabin Type" and produce rows:
    const tables = await page.locator("table:has-text('Cabin Type')").all();
    for (const tbl of tables) {
      const rows = await tbl.locator("tbody tr").all();
      for (const r of rows) {
        const tds = await r.locator("td").allTextContents();
        if (tds.length >= 3) {
          cabins.push({
            type: tds[0].trim(),
            available: parseInt(String(tds[1]).replace(/[^\d]/g,'')) || null,
            priceAUD: parseAusMoney(tds[2])
          });
        }
      }
    }
    return cabins;
  }

  // Fallback: more deterministic scrape by scanning each summary row in the main listings table
  const summaryRows = await page.locator("tbody tr").all();
  let idx = 0;
  for (const r of summaryRows) {
    const tds = await r.locator("td").allTextContents();
    // We expect at least: [Title, Depart, Return, Price, Availability] in some order
    if (tds.length < 4) { idx++; continue; }

    // Heuristics to classify columns:
    const joined = tds.join(" | ");
    const hasDepart = /Mon|Tue|Wed|Thu|Fri|Sat|Sun|Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec/.test(joined);
    const hasMoney = /\$\s?\d/.test(joined);
    if (!hasDepart || !hasMoney) { idx++; continue; }

    // Try to guess mapping: often like [Title, Departs, Returns, Price From, Availability]
    let title = tds[0].trim();
    let dep   = tds[1]?.trim();
    let ret   = tds[2]?.trim();
    let price = tds[3]?.trim();
    let avail = tds[4]?.trim() || tds[3]?.trim();

    // If we detect price token in col 4, keep; else adjust if format differs
    if (!/\$\s?\d/.test(price) && /\$\s?\d/.test(avail)) {
      // swap if needed
      [price, avail] = [avail, price];
    }

    // Parse dates and filter window
    const { depart, ret: retDate } = dmyToISO(dep, ret);
    if (!depart || !inWindow(depart)) { idx++; continue; }

    const cabins = await extractCabinsNear(idx);

    trips.push({
      title,
      dateText: dep,
      dateReturn: ret,
      priceFromAUD: parseAusMoney(price),
      availability: normStatus(avail),
      cabinsLeft: cabins.length ? cabins.reduce((a,c)=> a + (c.available||0), 0) : null,
      link: URL,
      cabins
    });

    idx++;
  }

  // Sort by departure date
  trips.sort((a,b) => new Date(a.dateText) - new Date(b.dateText));

  const json = {
    scrapedAt: new Date().toISOString(),
    source: URL,
    trips
  };

  await fs.writeFile("mikeball_availability.json", JSON.stringify(json, null, 2));
  console.log(`✅ Wrote ${trips.length} trips to mikeball_availability.json`);
  await browser.close();
})();
